{
  "hash": "8a26d2f9fc3c8d9fc53951f647c9db29",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"US Presidential Elections - A Bayesian Perspective\"\ndescription: \"I want to be a pollster too!\"\nauthor: \"Tomer Zipori\"\ncategories: [code, Bayes, visualization, ggplot2, polls]\nimage: \"favicon.png\"\nexecute: \n  warning: false\n  message: false\n  cache: false\nformat:\n  html:\n    theme: cosmo\n    toc: true\n    toc-depth: 3\n    toc-location: right\n    embed-resources: false\neditor: visual\n---\n\n\n\n# Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) # As always\nlibrary(brms)      # For Bayesian modeling\nlibrary(tidybayes) # For visualization\nlibrary(patchwork)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n# Introduction\n\nEver since I've finished my grad studies (Few months ago), I wanted to experiment with some \"real life\" applications of statistics. Things that interest real people. With the 2024 American presidential elections being the hot issue around the world, and Bayesian statistics being the hot issue of my personal projects, I thought how can these two mix.\n\nTwo features of Bayesian statistics pop to mind when thinking about election polling:\n\n## Prior Distributions\n\nThe need to explicitly define a prior distribution for any Bayesian model is a point of contention. Some (rightfully) argue that this definition can't be objective, and it is practically impossible to represent the existing body of knowledge in a single probability distribution. Others (rightfully) argue that every statistical model have prior assumptions which are rarely checked, and can influence the model as much as a prior distribution.[^1]\n\n[^1]: For a more deep discussion on prior distributions, see this [post](https://tomerzipori.github.io/blog/posts/bayes101/).\n\nOne reason the incorporation of past studies into the prior distribution is hard, is that it depends on the specific parameters of the model. While this make things hard in many cases, election polling is one area where it should be relatively easy! every poll is essentially the same statistical model (how many votes for red, and how many votes for blue), but with different data every time. This is the ideal scenario for a Bayesian statistician as the posterior distribution (the result) of any poll can be used as the prior distribution for the next poll!\n\n## Posterior Predictive Distributions\n\nOne tool of Bayesian statistical inference is the Posterior Predictive Distributions - PPD. This is the prediction of the model. For example, one possible PPD from a Bayesian election poll could be the expected electoral college result for each candidate, or the expected number of seats in the parliament.\n\n# Data\n\nThe following dataset is a summary of many polls conducted from the start of 2023, up to two days before the election.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_csv(\"../elections2024/president_polls.csv\", show_col_types = F)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 18,095\nColumns: 52\n$ poll_id                   <dbl> 89372, 89372, 89372, 89372, 89372, 89372, 89…\n$ pollster_id               <dbl> 1528, 1528, 1528, 1528, 1528, 1528, 1528, 15…\n$ pollster                  <chr> \"AtlasIntel\", \"AtlasIntel\", \"AtlasIntel\", \"A…\n$ sponsor_ids               <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ sponsors                  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ display_name              <chr> \"AtlasIntel\", \"AtlasIntel\", \"AtlasIntel\", \"A…\n$ pollster_rating_id        <dbl> 546, 546, 546, 546, 546, 546, 546, 546, 546,…\n$ pollster_rating_name      <chr> \"AtlasIntel\", \"AtlasIntel\", \"AtlasIntel\", \"A…\n$ numeric_grade             <dbl> 2.7, 2.7, 2.7, 2.7, 2.7, 2.7, 2.7, 2.7, 2.7,…\n$ pollscore                 <dbl> -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0…\n$ methodology               <chr> \"Online Ad\", \"Online Ad\", \"Online Ad\", \"Onli…\n$ transparency_score        <dbl> 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,…\n$ state                     <chr> NA, NA, NA, NA, NA, NA, NA, \"Arizona\", \"Ariz…\n$ start_date                <chr> \"11/3/24\", \"11/3/24\", \"11/3/24\", \"11/3/24\", …\n$ end_date                  <chr> \"11/4/24\", \"11/4/24\", \"11/4/24\", \"11/4/24\", …\n$ sponsor_candidate_id      <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ sponsor_candidate         <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ sponsor_candidate_party   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ endorsed_candidate_id     <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ endorsed_candidate_name   <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ endorsed_candidate_party  <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ question_id               <dbl> 216453, 216453, 216453, 216453, 216453, 2164…\n$ sample_size               <dbl> 2703, 2703, 2703, 2703, 2703, 2703, 2703, 87…\n$ population                <chr> \"lv\", \"lv\", \"lv\", \"lv\", \"lv\", \"lv\", \"lv\", \"l…\n$ subpopulation             <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ population_full           <chr> \"lv\", \"lv\", \"lv\", \"lv\", \"lv\", \"lv\", \"lv\", \"l…\n$ tracking                  <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ created_at                <chr> \"11/4/24 19:06\", \"11/4/24 19:06\", \"11/4/24 1…\n$ notes                     <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ url                       <chr> \"https://atlasintel.org/poll/usa-national-20…\n$ url_article               <chr> \"https://atlasintel.org/poll/usa-national-20…\n$ url_topline               <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ url_crosstab              <chr> \"https://cdn.atlasintel.org/f1cec70d-8eae-44…\n$ source                    <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ internal                  <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ partisan                  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ race_id                   <dbl> 8914, 8914, 8914, 8914, 8914, 8914, 8914, 87…\n$ cycle                     <dbl> 2024, 2024, 2024, 2024, 2024, 2024, 2024, 20…\n$ office_type               <chr> \"U.S. President\", \"U.S. President\", \"U.S. Pr…\n$ seat_number               <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ seat_name                 <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ election_date             <chr> \"11/5/24\", \"11/5/24\", \"11/5/24\", \"11/5/24\", …\n$ stage                     <chr> \"general\", \"general\", \"general\", \"general\", …\n$ nationwide_batch          <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA…\n$ ranked_choice_reallocated <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA…\n$ ranked_choice_round       <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ hypothetical              <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA…\n$ party                     <chr> \"DEM\", \"REP\", \"GRE\", \"IND\", \"LIB\", \"DEM\", \"R…\n$ answer                    <chr> \"Harris\", \"Trump\", \"Stein\", \"West\", \"Oliver\"…\n$ candidate_id              <dbl> 16661, 16651, 31116, 31097, 31790, 16661, 16…\n$ candidate_name            <chr> \"Kamala Harris\", \"Donald Trump\", \"Jill Stein…\n$ pct                       <dbl> 48.1, 49.2, 1.1, 0.3, 0.1, 48.8, 50.0, 45.9,…\n```\n\n\n:::\n:::\n\n\n\n# Preprocessing\n\nSome preprocessing and cleaning is needed here, mainly I want to include only recent polls to avoid dealing with a large number of candidates, and transforming the percentage of votes into a probability:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_clean <- data |>\n  select(poll_id, state, poll_date = start_date, question_id, candidate_name, sample_size, pct) |> # selecting relevant cols only\n  mutate(pct = pct / 100,               # transforming to probabilities\n         poll_date = mdy(poll_date)) |> # transforming to 'date' types\n  filter(year(poll_date) >= 2024 & month(poll_date) >= 10) |> # only recent polls to control for speculative candidates\n  mutate(candidate_name = relevel(factor(candidate_name), ref = \"Donald Trump\")) |> # Defining 'Trump' to be the reference level\n  group_by(poll_id) |>                  # some polls have several q's, this keeps only the main 'who would you vote for' question\n  filter(question_id == min(question_id)) |>\n  ungroup()\n```\n:::\n\n\n\n# Modeling\n\nFrom a statistical point of view, an election poll is a multiclass classification problem: It estimates the real proportion of votes for each candidate in the population, from the sampled proportions. The dependent variable is categorical and does not have any ordering. Since we don't have any predictors other than the observed proportions, the model is what is called an *empty* model - and it's formulation in `R` is usually represented as: `DV ~ 1`. Due to the structure of the current data, each observation (row) need to be weighted by the observed percentage. In order to include weighting by the poll's sample size, I multiplied this percentage by the sample size.\n\nThis multiclass classification problem can be represented with a series of logistic models, each models one category (candidate) against the others as a binary outcome. In order to do that, I will use the `categorical()` family implemented in `brms`.\n\nLet's start with a simple case, and model results only for Nevada:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_clean_nv <- data_clean |>\n  filter(state == \"Nevada\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbayesian_model_nv <- brm(formula = candidate_name|weights(sample_size*pct) ~ 1,\n                         family = categorical(link = \"logit\"),\n                         data = data_clean_nv,\n                         chains = 10,\n                         cores = 10,\n                         iter = 4000,\n                         refresh = 0,\n                         seed = 14,\n                         backend = \"cmdstanr\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bayesian_model_nv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: categorical \n  Links: muChaseOliver = logit; muCornelWest = logit; muJillStein = logit; muJoelSkousen = logit; muKamalaHarris = logit \nFormula: candidate_name | weights(sample_size * pct) ~ 1 \n   Data: data_clean_nv (Number of observations: 85) \n  Draws: 10 chains, each with iter = 4000; warmup = 2000; thin = 1;\n         total post-warmup draws = 20000\n\nRegression Coefficients:\n                         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS\nmuChaseOliver_Intercept     -4.92      0.11    -5.14    -4.71 1.00     8712\nmuCornelWest_Intercept     -15.07     10.71   -36.77    -8.70 1.00     2989\nmuJillStein_Intercept       -6.10      0.20    -6.51    -5.73 1.00     8233\nmuJoelSkousen_Intercept    -15.53     12.01   -39.09    -8.70 1.00     2538\nmuKamalaHarris_Intercept     0.00      0.01    -0.02     0.03 1.00     9124\n                         Tail_ESS\nmuChaseOliver_Intercept      9672\nmuCornelWest_Intercept       1751\nmuJillStein_Intercept        7736\nmuJoelSkousen_Intercept      1491\nmuKamalaHarris_Intercept     9396\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\nA few things to notice here: first, Trump doesn't have a parameter. That is because `brms` estimates each parameter in comparison to the factor's reference level, which is set to $0$, or $1$ on the exponential scale. Second, parameter estimates are logits, as this is essentially an output of multiple logistic regressions. In order to transform these estimates into predicted vote shares for every candidate $j$ out of the $K$ total candidates, a softmax transformation need to be applied:\n\n$$\nP(j)=\\frac{e^{Intercept_j}}{\\sum_{k=1}^K e^{Intercept_k}}\n$$\n\nExtracting more precise point-estimates:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraws_nv <- spread_draws(bayesian_model_nv, b_muChaseOliver_Intercept, b_muCornelWest_Intercept, b_muJillStein_Intercept, b_muJoelSkousen_Intercept, b_muKamalaHarris_Intercept)\n\n(c(median(draws_nv$b_muChaseOliver_Intercept), median(draws_nv$b_muCornelWest_Intercept), median(draws_nv$b_muJillStein_Intercept), median(draws_nv$b_muJoelSkousen_Intercept), median(draws_nv$b_muKamalaHarris_Intercept)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  -4.913210000 -12.452300000  -6.088395000 -12.626300000   0.002381675\n```\n\n\n:::\n:::\n\n\n\nFor example, applying the softmax transformation in order to get the predicted vote share of Jill Stein:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n100 * exp(-6.088395) / (exp(-4.91321) + exp(-12.4523) + exp(-6.088395) + exp(-12.6263) + exp(0.002381675) + exp(0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1127752\n```\n\n\n:::\n:::\n\n\n\nAbout 0.1%.\n\nThe predicted vote share of Kamala Harris is:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n100 * exp(0.002381675) / (exp(-4.91321) + exp(-12.4523) + exp(-6.088395) + exp(-12.6263) + exp(0.002381675) + exp(0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 49.82007\n```\n\n\n:::\n:::\n\n\n\nAnd of Donald Trump:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n100 * exp(0) / (exp(-4.91321) + exp(-12.4523) + exp(-6.088395) + exp(-12.6263) + exp(0.002381675) + exp(0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 49.70155\n```\n\n\n:::\n:::\n\n\n\nBut, this is a Bayesian model so let's not stay stuck with point estimates and look at the whole posterior distribution:\n\nExtracting draws:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprobs_nv <- draws_nv |>\n  select(-.chain, -.iteration) |>\n  mutate(b_muChaseOliver_Intercept = exp(b_muChaseOliver_Intercept),\n         b_muKamalaHarris_Intercept = exp(b_muKamalaHarris_Intercept),\n         b_muJillStein_Intercept = exp(b_muJillStein_Intercept),\n         b_muCornelWest_Intercept = exp(b_muCornelWest_Intercept),\n         b_muJoelSkousen_Intercept = exp(b_muJoelSkousen_Intercept)) |>\n  mutate(row_sum = b_muChaseOliver_Intercept + b_muKamalaHarris_Intercept + b_muJillStein_Intercept + b_muCornelWest_Intercept + b_muJoelSkousen_Intercept + 1) |>\n  mutate(Trump = 1 / row_sum,\n         Harris = b_muKamalaHarris_Intercept / row_sum) |>\n  select(.draw, Trump, Harris)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprobs_nv |>\n  pivot_longer(cols = c(Trump, Harris),\n               names_to = \"Candidate\",\n               values_to = \"prob\") |>\n  ggplot(aes(x = prob * 100, fill = Candidate)) +\n  stat_slab(color = \"gray24\", alpha = 0.7) +\n  scale_fill_manual(values = c(\"#2166AC\", \"#B2182B\")) +\n  scale_x_continuous(breaks = seq(48, 52, 0.2), labels = seq(48, 52, 0.2)) +\n  labs(x = \"Predicted vote share in %\") +\n  theme_classic() +\n  theme(axis.title.y = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nVery close!\n\nAnd what is the predicted difference between the two main candidates?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprobs_nv |>\n  mutate(diff = Trump - Harris) |>\n  ggplot(aes(x = diff * 100, fill = after_stat(x > 0))) +\n  stat_slab(color = \"gray24\") +\n  geom_vline(xintercept = 0, linetype = \"dashed\") +\n  scale_fill_manual(values = c(\"#2166AC\", \"#B2182B\"), labels = c(\"Harris win\", \"Trump win\")) +\n  scale_x_continuous(breaks = seq(-3, 4, 0.5), labels = seq(-3, 4, 0.5)) +\n  labs(x = \"Predicted vote share difference in %\", fill = \" \") +\n  theme_classic() +\n  theme(axis.title.y = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nAgain, very close (with a slight advantage to Harris).\n\nAnother useful measure from Bayesian statistics is the probability of direction (pd). Due to the winner-takes-all electoral system in 48 of the 50 states, the difference doesn't really matter. So what is the probability that each candidate will win?\n\nThe probability that Trump will win is seen in the red area in the plot above, that is the probability that the difference in vote share is positive:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff <- probs_nv$Trump - probs_nv$Harris\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(diff[diff > 0]) / length(diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.42815\n```\n\n\n:::\n:::\n\n\n\nTrump has a 42.82% chance of winning Nevada.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(diff[diff < 0]) / length(diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.57185\n```\n\n\n:::\n:::\n\n\n\nAnd Harris has 57.19% chance.\n\nLet's make the plot a little more informative:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff_plot <- probs_nv |>\n  mutate(diff = Trump - Harris) |>\n  mutate(diff = diff * 100) |>\n  ggplot(aes(x = diff, fill = after_stat(cut(x, breaks = c(-Inf, -2, -1, 0, 1, 2, Inf), labels = c(\"Harris by more than 2%\", \"Harris by 1%-2%\", \"Harris by less than 1%\", \"Trump by less than 1%\", \"Trump by 1%-2%\", \"Trump by more than 2%\"))))) +\n  stat_slab(color = \"gray24\") +\n  scale_fill_manual(values = rev(RColorBrewer::brewer.pal(6, \"RdBu\"))) +\n  scale_x_continuous(limits = c(-3, 3), breaks = seq(-3, 3, 0.5), labels = seq(-3, 3, 0.5)) +\n  labs(fill = \" \", x = \"Predicted Difference in %\", title = \"Predicted difference in votes - Nevada\") +\n  theme_classic() +\n  theme(axis.title.y = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank(),\n        plot.title = element_text(family = \"serif\", size = 22, hjust = 0.5))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n## Eliciting a custom prior\n\nFor the last model we used brms' default prior. In order to elicit our own, For simplicity, I'll start with the 2020 vote share between Biden and Trump:\n\n![2020 Results - Nevada (from [Wikipedia](https://en.wikipedia.org/wiki/2020_United_States_presidential_election_in_Nevada))](2020_results_nv.png)\n\n::: callout-note\nThis part contain some math. Don't skip it, you can understand it! But if you want to skip it, go to the 'Modeling with a custom prior' section.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprior_trump <- 0.4767\nprior_harris <- 0.5006\n```\n:::\n\n\n\nThese percentages need to be transformed to the logistic model's scale, now using the inverse-softmax transformation:\n\n$$\n0.5006=softmax(Intercept_{Harris})=\\frac{e^{Intercept_{Harris}}}{\\sum_{k=1}^K e^{Intercept_k}}\n$$\n\nAnd:\n\n$$\n0.4767=softmax(Intercept_{Trump})=\\frac{e^{Intercept_{Trump}}}{\\sum_{k=1}^K e^{Intercept_k}}\n$$\n\nBut with Trump's intercept fixed to $0$ as the factor's reference level, it's possible to calculate the sum in the denominator:\n\n$$\n0.4767=\\frac{1}{\\sum_{k=1}^K e^{Intercept_k}}\n$$\n\nQuick algebra gives:\n\n$$\n\\sum_{k=1}^K e^{Intercept_k}=\\frac{1}{0.4767}=2.097755\n$$\n\nNow it's possible to calculate Harris' intercept:\n\n$$\n0.5006=\\frac{e^{Intercept_{Harris}}}{2.097755}\n$$\n\n$$\ne^{Intercept_{Harris}}=0.5006 \\cdot 2.097755=1.050136\n$$\n\n$$\nIntercept_{Harris}=ln(1.050136)=0.04891968\n$$\n\nA quicker way to derive these intercepts is to notice that for every candidate $j$ other than the 'reference' candidate $r$, the intercept is:\n\n$$\nIntercept_j=ln(\\frac{P(j)}{P(r)})\n$$\n\nWhere $P(j)$ and $P(r)$ are the assumed vote shares of candidate $j$ and $r$ respectively.\n\n# Modeling with a custom prior\n\nSetting the prior for Harris' intercept, giving it relatively large standard deviation reflecting the many factors differentiating the 2024 and 2020 elections.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprior_nv <- set_prior(\"normal(0.04891968, 0.1)\", class = \"Intercept\", dpar = \"muKamalaHarris\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbayesian_model_nv_wprior <- brm(formula = candidate_name|weights(sample_size*pct) ~ 1,\n                                family = categorical(link = \"logit\"),\n                                data = data_clean_nv,\n                                prior = prior_nv,\n                                chains = 10,\n                                cores = 10,\n                                iter = 4000,\n                                refresh = 0,\n                                seed = 14,\n                                backend = \"cmdstanr\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bayesian_model_nv_wprior)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: categorical \n  Links: muChaseOliver = logit; muCornelWest = logit; muJillStein = logit; muJoelSkousen = logit; muKamalaHarris = logit \nFormula: candidate_name | weights(sample_size * pct) ~ 1 \n   Data: data_clean_nv (Number of observations: 85) \n  Draws: 10 chains, each with iter = 4000; warmup = 2000; thin = 1;\n         total post-warmup draws = 20000\n\nRegression Coefficients:\n                         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS\nmuChaseOliver_Intercept     -4.92      0.11    -5.14    -4.71 1.00    10322\nmuCornelWest_Intercept     -14.79      7.81   -36.48    -8.68 1.01     2915\nmuJillStein_Intercept       -6.09      0.20    -6.50    -5.72 1.00     9801\nmuJoelSkousen_Intercept    -15.41     11.07   -37.29    -8.72 1.00     2797\nmuKamalaHarris_Intercept     0.00      0.01    -0.02     0.03 1.00    10356\n                         Tail_ESS\nmuChaseOliver_Intercept     10191\nmuCornelWest_Intercept       1659\nmuJillStein_Intercept        9246\nmuJoelSkousen_Intercept      1551\nmuKamalaHarris_Intercept    10037\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\nI'll inspect the model again, this time using the `brms::posterior_epred()` function, generating predictions on the probability scale:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_data <- expand.grid(x = NA)\n\npred_probs_nv <- posterior_epred(bayesian_model_nv_wprior, newdata = new_data)\n```\n:::\n\n\n\nThis essentially creates a $20,000 \\times 6$ array of 20,000 \"simulated elections\" based on the model, and the vote share of each of the 6 candidates. For example, here are the first five simulated elections and the vote share in each:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred_probs_nv[1:5,,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Donald Trump Chase Oliver  Cornel West  Jill Stein Joel Skousen\n[1,]    0.4953947  0.003684427 5.757740e-05 0.001019819 1.934454e-05\n[2,]    0.4994877  0.004458325 1.934866e-06 0.001474521 1.406709e-05\n[3,]    0.5026360  0.003951306 1.079202e-06 0.001657708 8.114247e-06\n[4,]    0.5044252  0.003509907 9.118997e-07 0.001623817 1.605403e-06\n[5,]    0.4987907  0.003857605 2.889669e-06 0.001544016 5.206677e-06\n     Kamala Harris\n[1,]     0.4998241\n[2,]     0.4945634\n[3,]     0.4917458\n[4,]     0.4904386\n[5,]     0.4957995\n```\n\n\n:::\n:::\n\n\n\nTurning it into the same plots as before gives:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred_probs_nv_df <- data.frame(pred_probs_nv[,1,]) |>\n  mutate(poll_id = factor(c(1:n()))) |>\n  pivot_longer(cols = !poll_id,\n               names_to = \"Candidate\",\n               values_to = \"Proportion\") |>\n  mutate(Candidate = str_replace_all(Candidate, \"\\\\.\", \" \")) |>\n  mutate(Candidate = str_replace(Candidate, \"^\\\\S* \", \"\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprob_plot <- pred_probs_nv_df |>\n  filter(Candidate %in% c(\"Trump\", \"Harris\")) |>\n  ggplot(aes(x = 100 * Proportion, fill = Candidate)) +\n  ggdist::stat_slab(color = \"gray24\", alpha = 0.7) +\n  scale_fill_manual(values = c(\"#2166AC\", \"#B2182B\")) +\n  scale_x_continuous(breaks = seq(48, 52, 0.2), labels = seq(48, 52, 0.2)) +\n  labs(x = \"Predicted vote share in %\") +\n  theme_classic() +\n  theme(axis.title.y = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprob_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff_plot_wprior <- pred_probs_nv_df |>\n  filter(Candidate %in% c(\"Trump\", \"Harris\")) |>\n  pivot_wider(id_cols = poll_id,\n              names_from = Candidate,\n              values_from = Proportion) |>\n  mutate(diff = Trump - Harris) |>\n  mutate(diff = diff * 100) |>\n  ggplot(aes(x = diff, fill = after_stat(cut(x, breaks = c(-Inf, -2, -1, 0, 1, 2, Inf), labels = c(\"Harris by more than 2%\", \"Harris by 1%-2%\", \"Harris by less than 1%\", \"Trump by less than 1%\", \"Trump by 1%-2%\", \"Trump by more than 2%\"))))) +\n  ggdist::stat_slab(color = \"gray24\") +\n  scale_fill_manual(values = rev(RColorBrewer::brewer.pal(6, \"RdBu\"))) +\n  scale_x_continuous(limits = c(-3, 3), labels = seq(-3, 3, 0.5), breaks = seq(-3, 3, 0.5)) +\n  labs(fill = \" \", x = \"Predicted Difference in %\", title = \"Predicted difference in votes - Nevada\", subtitle = \"Custom Prior\") +\n  theme_classic() +\n  theme(axis.title.y = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank(),\n        plot.title = element_text(family = \"serif\", size = 22, hjust = 0.5),\n        plot.subtitle = element_text(family = \"serif\", size = 16, hjust = 0.5))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff_plot_wprior\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n\nHow much the custom prior has changed the result?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff_plot / diff_plot_wprior +\n  plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n\nVisually, not by much...\n\nAnd what about the predicted chance of each candidate of winning the state?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprobs_nv <- pred_probs_nv_df |>\n  filter(Candidate %in% c(\"Trump\", \"Harris\")) |>\n  pivot_wider(id_cols = poll_id,\n              names_from = Candidate,\n              values_from = Proportion)\n\ndiff <- probs_nv$Trump - probs_nv$Harris\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(diff[diff > 0]) / length(diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.40885\n```\n\n\n:::\n:::\n\n\n\nTrump now has a 40.89% chance of winning Nevada, compared with the 42.82% he had before.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(diff[diff < 0]) / length(diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.59115\n```\n\n\n:::\n:::\n\n\n\nAnd Harris has 59.12% chance, a slight increase from the 57.19% she had before.\n\nAlthough visually there hasn't been much of a change, the prior shifted the chances of winning by \\~2% in favor of Harris.\n\n# Running models for all states\n\nIn this section I run the same Bayesian model for each state. The better way of doing it will be to run one big model with `state` as a categorical predictor.[^2] This one-big-model method didn't converge on the current data, so I resort to run a separate model for each state.\n\n[^2]: Or as a factor with random levels, but I don't think it's theoretically correct in the US presidential elections.\n\nHere I define some functions to run on the list of states:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_b_model <- function(state) {\n  \n  data_clean_state <- data_clean[data_clean$state == state,]\n  \n  bayesian_model <- brm(formula = candidate_name|weights(sample_size*pct) ~ 1,\n                        family = categorical(link = \"logit\"),\n                        data = data_clean_state,\n                        chains = 10,\n                        cores = 10,\n                        iter = 4000,\n                        refresh = 0,\n                        seed = 14,\n                        backend = \"cmdstanr\")\n  \n  return(bayesian_model)\n}\n\nplots <- function(state) {\n  \n  b_model <- run_b_model(state = state)\n  \n  new_data <- expand.grid(x = NA)\n\n  pred_prob <- posterior_epred(b_model, newdata = new_data)\n\n  pred_prob_df <- data.frame(pred_prob[,1,]) |>\n    mutate(poll_id = factor(c(1:n()))) |>\n    pivot_longer(cols = !poll_id,\n                 names_to = \"Candidate\",\n                 values_to = \"Proportion\") |>\n    mutate(Candidate = str_squish(str_replace_all(Candidate, \"\\\\.\", \" \")))\n  \n  prob_plot <- pred_prob_df |>\n  filter(Candidate %in% c(\"Donald Trump\", \"Kamala Harris\")) |>\n  ggplot(aes(x = Proportion, fill = Candidate)) +\n  ggdist::stat_slab(alpha = 0.8) +\n  theme_classic() +\n  theme(axis.title.y = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank())\n  \n  \n  diff_df <- pred_prob_df |>\n   filter(Candidate %in% c(\"Donald Trump\", \"Kamala Harris\")) |>\n   pivot_wider(id_cols = poll_id,\n                names_from = Candidate,\n                values_from = Proportion) |>\n   mutate(diff = 100*(`Donald Trump` - `Kamala Harris`),\n          state = state) |>\n   mutate(diff_label = cut(diff, breaks = c(-Inf, -10, -5, -1, 0, 1, 5, 10, Inf), labels = c(\"Harris by more than 10%\", \"Harris by 10%-5%\", \"Harris by 5%-1%\", \"Harris by less than 1%\", \"Trump by less than 1%\", \"Trump by 5%-1%\", \"Trump by 10%-5%\", \"Trump by more than 10%\"))) |>\n   mutate(diff_label = factor(diff_label, levels = c(\"Harris by more than 10%\", \"Harris by 10%-5%\", \"Harris by 5%-1%\", \"Harris by less than 1%\", \"Trump by less than 1%\", \"Trump by 5%-1%\", \"Trump by 10%-5%\", \"Trump by more than 10%\"), ordered = TRUE))\n  \n  diff_plot <- diff_df |>\n    ggplot(aes(x = diff, fill = after_stat(cut(x, breaks = c(-Inf, -10, -5, -1, 0, 1, 5, 10, Inf), labels = c(\"Harris by more than 10%\", \"Harris by 10%-5%\", \"Harris by 5%-1%\", \"Harris by less than 1%\", \"Trump by less than 1%\", \"Trump by 5%-1%\", \"Trump by 10%-5%\", \"Trump by more than 10%\"))))) +\n    ggdist::stat_slab(color = \"gray30\") +\n    scale_fill_manual(values = rev(RColorBrewer::brewer.pal(8, \"RdBu\"))[sort(as.numeric(unique(diff_df$diff_label)))]) +\n    labs(fill = \"Difference in %\", x = \"Predicted Difference in %\", title = glue::glue(\"{state}\")) +\n    theme_classic() +\n    theme(axis.title.y = element_blank(),\n          axis.text.y = element_blank(),\n          axis.ticks.y = element_blank(),\n          plot.title = element_text(family = \"serif\", size = 22, hjust = 0.5))\n\n  return(list(model = b_model, prob = prob_plot, diff = diff_plot))\n\n}\n```\n:::\n\n\n\nRunning it on every state:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates <- lapply(X = unique(data_clean$state)[!(is.na(unique(data_clean$state)))],\n                 FUN = plots)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nExtracting the predicted difference between Harris and Trump in each state:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff_plots <- lapply(X = 1:43,\n                     FUN = function(x) {states[[x]]$diff})\n\none_big_plot <- patchwork::wrap_plots(diff_plots, ncol = 5, nrow = 9) +\n  plot_layout(guides = \"collect\") +\n  plot_annotation(theme = theme(legend.position = \"none\",\n                                plot.title = element_text(family = \"serif\", size = 14, hjust = 0.5)))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\none_big_plot\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n![](../elections2024/one_big_plot2.png){width=\"155%\" height=\"155%\"}\n\n# Expected Electoral College Results\n\nUsing the Bayesian model it is possible to calculate the expected electoral college results. For each 'simulated' election, I will calculate the electoral votes each candidate won.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelectors_df <- read_csv(\"../elections2024/2024_Electoral_College.csv\", show_col_types = FALSE) # Data frame containing elector count for each state\n```\n:::\n\n\n\nFor simulated election, the winner in each state is determined based on the predicted difference in votes (positive = Trump win, Negative = Harris win):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates_df_list <- lapply(X = 1:43,\n                    FUN = function(x) {states[[x]]$diff$data})\n\nstates_df <- do.call(\"rbind\", states_df_list) |>\n  mutate(diff_binary = case_when(diff > 0 ~ \"Trump\",\n                                 diff < 0 ~ \"Harris\")) |>\n  select(poll_id, diff_binary, state) |>\n  left_join(select(electors_df, State, Total), by = join_by(state == State)) |>\n  mutate(Total = case_when(state %in% c(\"Nebraska\", \"Maine\") ~ 2,\n                           .default = Total)) |>\n  replace_na(list(Total = 1))\n\nglimpse(states_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 860,000\nColumns: 4\n$ poll_id     <fct> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,…\n$ diff_binary <chr> \"Trump\", \"Trump\", \"Trump\", \"Trump\", \"Trump\", \"Trump\", \"Tru…\n$ state       <chr> \"Arizona\", \"Arizona\", \"Arizona\", \"Arizona\", \"Arizona\", \"Ar…\n$ Total       <dbl> 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11…\n```\n\n\n:::\n:::\n\n\n\nSumming all electors for each candidate in each simulated election (and completing the picture with states that were not polled):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpected_electors <- states_df |>\n  group_by(poll_id, diff_binary) |>\n  reframe(tot = sum(Total)) |>\n  mutate(tot = case_when(diff_binary == \"Trump\" ~ tot + 9 + 6 + 4 + 6 + 8 + 8 + 6 + 3 + 4,\n                         diff_binary == \"Harris\" ~ tot + 7 + 3 + 3 + 4))\n\nhead(expected_electors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  poll_id diff_binary   tot\n  <fct>   <chr>       <dbl>\n1 1       Harris        276\n2 1       Trump         262\n3 2       Harris        276\n4 2       Trump         262\n5 3       Harris        270\n6 3       Trump         268\n```\n\n\n:::\n:::\n\n\n\nVisualizing each electoral result for both candidate, and their predicted probability:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpected_electors |>\n  drop_na(diff_binary) |>\n  group_by(diff_binary, tot) |>\n  reframe(count = n()) |>\n  mutate(percent = count/sum(count)) |>\n  ggplot(aes(x = tot, y = percent, fill = diff_binary)) +\n  geom_bar(stat = \"identity\") +\n  scale_x_continuous(limits = c(225, 315), breaks = seq(225, 315, 5), labels = seq(225, 315, 5)) +\n  scale_fill_manual(values = c(\"#2166AC\", \"#B2182B\")) +\n  labs(y = \"Predicted Probability\", x = \"Electors Won\", fill = \"Candidate\") +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\n\nThe most probable results are a narrow electoral win for Harris, with over representation for Trump in the high end, and for Harris on the low end. This could be understood as higher probability for a Trump landslide, rather than a Harris landslide.\n\nCalculating the most probable results:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprobable_outcomes <- expected_electors |>\n  drop_na(diff_binary) |>\n  pivot_wider(names_from = diff_binary,\n              values_from = tot,\n              id_cols = poll_id) |>\n  count(Harris, Trump) |>\n  rename(count = n) |>\n  mutate(count = count / sum(count)) |>\n  unite(outcome, Harris:Trump, remove = FALSE, sep = \":\")\n```\n:::\n\n\n\nTop 20 most probable results:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop20_probable_outcomes <- probable_outcomes |>\n  arrange(desc(count)) |>\n  head(20) |>\n  mutate(Winner = case_when(Trump > Harris ~ \"Trump\",\n                            .default = \"Harris\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(top20_probable_outcomes, aes(x = reorder(outcome, count), y = count, fill = Winner)) +\n  geom_bar(stat = \"identity\", color = \"gray44\") +\n  scale_fill_manual(values = c(\"Harris\" = \"#2166AC\", \"Trump\" = \"#B2182B\")) +\n  labs(\n    title = \"Top 20 Most Probable Electoral Results\",\n    x = \"Electoral Result\",\n    y = \"Probability\",\n    fill = \"Winner\"\n  ) +\n  theme_classic() +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.title = element_text(hjust = 0.5, size = 16)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n:::\n\n\n\n# Conclusion\n\nOf course there are a lot more interesting calculations and visualizations that can be derived from the current Bayesian model, and from other models. This is a first attempt at implementing Bayesian statistical methods in the election polling field, I had fun.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}